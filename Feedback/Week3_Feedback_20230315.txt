Starting code feedback for Aditi, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 3.98 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, week7, week3, week2, Feedback, miniproject, week1

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~
*.tmp
*.log
/.idea
/.ipynb_checkpoints
/__pycache__
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
## My CMEE Coursework Repository

This GitHub repository has coursework and code for the work done during MRes in CMEE. Every week has a different folder and it contains sub-folders containing the code, data and results. 

### Week 1
Week one covers the basics of the Unix environment and shell scripting. The OS used for this course is Ubuntu 22.04 LTS. For the shell scripting, the bash shell is used. The scripts and code are present in the code directory and the data is availabe in the data directory.

### Week 2
Week two covers the basics of Python. Python version 3.10.6 is used for this course. Along with this, Visual Studio Code is the IDE used. The scripts and programs are present in the code directory. It also contains the groupwork scripts. The data required for the codes to run is present in the data directory. The results directory is empty currently and will be populated with the outputs of the scripts and programs. The sandbox directory is empty. 

### Week 3
Week 3 covers the basics of R. R vesion 4.1.2 ('Bird Hippie') is used. The IDE used is RStudio. The scripts and one report written in LaTex and its compiled PDF file are present in the code directory. It also contains the groupwork scripts. The data required to run all the scripts is present in the data dirrectory (including the images required to compile the LaTex). The results directory is currently empty and will be populated once all the scripts are run. The sandbox is empty and just for practice. 

### Week 7
Week seven covers a little advanced Python. Python version 3.10.6 is used for this course. Along with this, Visual Studio Code is the IDE used. The scripts and programs are present in the code directory. It also contains the groupwork scripts. The data required for the codes to run is present in the data directory. The results directory is empty currently and will be populated with the outputs of the scripts and programs. The sandbox directory is empty. 

### Miniproject
Miniproject is a workflow created to analyse a bacterial population growth dataset. For the analysis R(v 4.1.2: 'Bird Hippie') and RStudio IDE  were used. The scripts are all wriiten in R and a report written is written in Latex. A main run script (bash) can be used to run the entire workflow. The data and the metadata required is present in the data directory. The results directory is currently enpty but will be populated with graphs and images upon completion of the workflow. The sandox has the practice files and scripts and will always be empty.   
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 4 weekly directories: week1, week2, week3, week7

The Week3 directory will be assessedO 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: code, sandbox, results, data

Found the following files: README.md, .gitignore

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
## Week 3

### This document outlines the contents of week 3

'week3' contains four directories namely 'code', 'data', 'results, 'sandbox'. This week is based on R and all the scripts are written in RStudio

#### Code
This directory contains all R scripts and files containing code that are required for submission. All the scripts have to be called using this directory as the present working directory. The following is a short description of the files present in this directory:

* basic_io.R: A basic R script illustrating reading and writing files using R. In class script. 
* control_flow.R: R script showing various control flow methods in R. In class script. 
* next.R: Using the 'next' function. In class script.
* break.R: Using 'break' function in while loop. In class script. 
* boilerplate.R: A boilerplate function showing arguements. In class script. 
* R_conditionals.R: A script creating basic conditional functions. In class script.
* TreeHeight.R: Using a input .csv file to calculate the heights of trees given in the file and saving the output as TreeHts.csv. 
* Vectorize1.R: Comapring running time differences for loops and vectorized functions with and without preallocation. In class script.
* preallocate.R: Comparing run time differences with and without preallocation. In class script.
* apply1.R: Using the 'apply' function in R. In class script.
* apply2.R: Using the 'apply' function across a matrix. In class script.
* sample.R: Creating a random population and then carrying out operations loopy way with and without preallocation. In class script.
* Ricker.R: R script simulating growth using the Rickcer model. In class script.
* Vectorize2.R: R script doing a stochastic simulatio of the Ricker model with and without vectorization and comparing the time.
* browse.R: A script illustrating the use of 'browse' function in R. In class script.
* try.R: A script using the 'try' and 'doit' functions in R. In class script.
* Florida.R: A simple code to check if Florida is getting warmer. It also has a mini-report written in LaTeX and PDF output of it.
* Florida_Latex.tex: A LaTeX file for reporting the results.
* DataWrang.R: Wrangling data using base R and then converting it to tibble. In class script.
* DataWrangTidy.R: Repeating the DataWrang.R using tidyverse.
* PP_Dist.R: Plotting predator and prey mass distribution by Type of feeding interaction using base R plots. Also, saving the mean and median of the distributions as a .csv file
* PP_Regress.R: Plotting Predator and prey mass relationship using ggplot and also saving the regression results as a .csv file. 
* GPDD_Data.R: Superimposing species distribution on the world map in R.
* Girko.R: Creating a visulization of Girko's circular law. In class script.
* MyBars.R: Annotating a plot using ggplot. In class script.
* plotLin.R: Using ggplot to plot and annotate a liner regression. In class script. 
* SQLinR.R: Very basic SQL script in R. 

The following groupwork files are also present in the folder:

* PP_regress_loc.R - The linear regression relationship between the predator mass and prey mass is examined, and the analysis is separate by the dataset's *Location* field.

* TAutoCorr.R - The source script to answer the question: "Are temperatures of one year significantly correlated with the next year (successive years), across years in a given location?"

* FloridaYears.tex - The interpretation of the results generated by the script *TAutoCorr.R*.

* get_TreeHeight.R - This script takes the input from the command line and saves the output in the results directory. 

* get_TreeHeight.py - This is the Python version of the above script.

* run_get_TreeHeight.sh - The shell script runs the above two scripts with the default input, which is the 


The follwing R packages are required to run the script:
* tidyverse
* maps
* reshape2
* sqldf

The following Python packages are required for the python script:

* sys - used for taking the input parameter from command line

* os - used to split the string of input and eliminate the extension in R

* pandas - for csv reading

* numpy - for mathematical operation when defining the tree height

* tools - used to split the string of input and eliminate the extension in Python

Please be sure to install them in your R and Python environments to run the scripts without errors. 

#### Data
This directory has all the data required by the scripts. It also contains the images used for the Florida_results.tex 

#### Results
This directory id empty presently. After running all the scripts it is expected to contain the results given by the scripts.

#### Sandbox
This directory is for practice and contains practice scripts and files. On GitHub it is empty as it is not meant for submission. 
**********************************************************************

Results directory is empty - good! 

Found 33 code files: apply2.R, apply1.R, Girko.R, next.R, plotLin.R, Florida.R, sample.R, PP_Dists.R, get_TreeHeight.py, SQLinR.R, try.R, PP_regress_loc.R, FloridaYears.tex, MyBars.R, control_flow.R, TAutoCorr.R, Ricker.R, boilerplate.R, R_conditionals.R, browse.R, GPDD_Data.R, PP_Regress.R, get_TreeHeight.R, Vectorize2.R, DataWrangTidy.R, preallocate.R, break.R, run_get_TreeHeight.sh, DataWrang.R, TreeHeight.R, basic_io.R, Vectorize1.R, Florida_results.tex

Found the following extra files: Florida_results.pdf
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# A weird function
# Returns the vector multiplied by 100 if the sum of the vector 4
#elements is greater then 0
# Else returns the vector as is

SomeOperatiion <- function(v){
    if(sum(v)>0){
        return(v * 100)
    } else{
        return(v)
    }
}

M <- matrix(rnorm(50), 2 , 25)
print(apply(M, 1, SomeOperatiion))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
              [,1]         [,2]
 [1,]   -0.7600608 -0.906194768
 [2,]  -59.6691757  0.647874101
 [3,]  -13.9090001  0.460455222
 [4,]  129.7475299 -0.137273682
 [5,]  -17.1081673 -1.791729576
 [6,]   -3.1570258 -1.510086379
 [7,]   58.9082319 -0.456496837
 [8,]  -10.0461728 -0.459940869
 [9,]  -92.6533467  0.386099088
[10,] -204.6691752  0.633182653
[11,]  -47.0320837  0.380385300
[12,]   -8.9938465  0.363211513
[13,]   50.6035230  0.613224036
[14,]  -36.7899417  0.450773922
[15,]   -8.1334705  1
**********************************************************************

Code ran without errors

Time consumed = 0.19871s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# Building a random matrix
M <- matrix(rnorm(100), 10, 10)

# Mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)

# Variance of each row
RowVar <- apply(M, 1, var)
print(RowVar)

# Mean of each column 
ColMeans <- apply(M, 2, mean)
print(ColMeans)

# Variance of each column
ColVAr <- apply(M, 2, var)
print(ColVAr)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1] -0.15824364  0.38519279 -0.52673728  0.03668721 -0.17411767  0.29761611
 [7]  0.11999551  0.23857586  0.28424009  0.08478060
 [1] 1.4628496 1.5341443 1.1728803 0.9931014 0.8949475 1.2303743 1.0676561
 [8] 0.9402765 1.3758465 0.7198929
 [1]  0.13140542 -0.05793435 -0.37012653 -0.25008237 -0.01626712  0.13339244
 [7] -0.01215907  0.25425509  0.37553038  0.39997570
 [1] 1.4534818 1.2140101 0.9190847 2.1359802 0.6400141 1.1229241 1.3710026
 [8] 0.7796354 1.1368161 0.7594522

**********************************************************************

Code ran without errors

Time consumed = 0.19086s

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
# cleaning the environment
rm(list = ls())

# Loading the required libraries
library(tidyverse)

# Simulating an ellipse
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
    npoints = 250
    a <- seq(0, 2 * pi, length = npoints + 1)
    x <- hradius * cos(a)
    y <- vradius * sin(a)  
    return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns

# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
    geom_point(shape = I(3)) +
    theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

pdf("../results/Pred_subplots.pdf", 11.7, 8.3)
print(p)
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************
pdf 
  2 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
# Next in a for loop in R

# Cleaning environment
rm(list = ls())

# Actual code begin
for(i in 1:10){
    if((i %% 2) == 0){
        next
    }
    print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.19601s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# Loading required packages
require(tidyverse)

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
    rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
    geom_point() +
    scale_colour_gradient(low = "black", high = "red") +
    theme(legend.position = "none") +
    scale_x_continuous(
        expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
    intercept = my_lm$coefficients[1][1],
    slope = my_lm$coefficients[2][1],
    colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

p

pdf("../results/MyLinReg.pdf", 11.7, 8.3)
print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************
pdf 
  2 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file Florida.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list=ls())

# Loading the required packages
require(tidyverse)

# Loading the data from the data directory
load("../data/KeyWestAnnualMeanTemperature.RData")
ls()

# Looking at the data
class(ats)
head(ats)

# Plotting the original data with a regression line
p <- ggplot(ats, aes(x = Year, y = Temp)) + 
    geom_point() + geom_smooth(method = "lm")
p <- p + theme_bw()
p

# Storing the observed correlation coefficient
o_cor <- cor(ats$Year, ats$Temp)

# Setting the number of resampling itterations
n <- 10000
# Creating a vector to store the correlation coefficient for each resampling
cor_vec <- vector(, n)

# Resampling and calculating the correlation coefficient for each resampling 
# and storing it in the vector the loopy way
for(i in 1:n){
    tmp <-  sample(ats$Temp, replace = F)
    cor_vec[i] <- cor(ats$Year, tmp)
}

# Plotting the histogram for the simulated cor and the overseved cor as an abline
g <- ggplot(data = as.data.frame(cor_vec), aes(x=cor_vec))+
    geom_histogram(aes(y=..density..), bins = 50, fill = I('#505F90')) +
    geom_density(colour = 'red')+
    theme_bw() 
g<- g + geom_vline(aes(xintercept=o_cor), colour="red", lwd = 1.1) +
    labs(title = "Histogram of the permutation analysis", 
         x = "Correlation coefficient") + 
    theme(plot.title = element_text(hjust = 0.5))
g

# Printing the probability of observed coefficient 
print(paste("The probabilty that the observed coefficient is by chance is:", sum(cor_vec > o_cor)/n))

**********************************************************************

Testing Florida.R...

Output (only first 500 characters): 


**********************************************************************
[1] "ats"
[1] "data.frame"
  Year     Temp
1 1901 23.75000
2 1902 24.66667
3 1903 24.71667
4 1904 24.51667
5 1905 24.88333
6 1906 24.63333
[1] "The probabilty that the observed coefficient is by chance is: 0"

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
`geom_smooth()` using formula 'y ~ x'

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

#### Functions #####

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){
    pop_sample <- sample(popn, n, replace = F)
    return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num){
    result1 <- vector()
    for(i in 1:num){
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
    result2 <- vector(,num)
    for (i in 1:num){
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
    result3 <- vector('list', num)
    for (i in 1:num){
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}

## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num){
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

set.seed(12345)
popn <- rnorm(10000)
hist(popn)

n <- 100
num <- 100000

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector took:"

**********************************************************************

Code ran without errors

Time consumed = 10.00923s

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Loading the required packages
require(tidyverse)

# Loading the data 
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")

# Converting the Prey masses in mg to g
MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg'] <-
    MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg']/1000

# Subsection for plotting log Predator mass
pdf("../results/Pred_subplots.pdf", 11.7, 8.3)
par(mfrow=c(2,3))
for(type in unique(MyDF$Type.of.feeding.interaction)){
    tmp <- MyDF %>% filter(Type.of.feeding.interaction == type)
    hist(log(tmp$Predator.mass), 
         main = type, xlab = "log mass value")
}
mtext("Subplots showing the log of Predtor mass by feeding interaction", side = 3, line = -1.5, outer = TRUE)
par(mfrow = c(1,1))
dev.off()

# Subsection for plotting log Prey mass
pdf("../results/Prey_Subplots.pdf", 11.7, 8.3)
par(mfrow = c(2,3))
for(type in unique(MyDF$Type.of.feeding.interaction)){
    tmp <- MyDF %>% filter(Type.of.feeding.interaction == type)
    hist(log(tmp$Prey.mass), 
         main = type, xlab = "log mass value", breaks=seq(-25,10, by=5))
}
mtext("Subplots showing the log of Prey mass by feeding interaction", side = 3, line = -1.5, outer = TRUE)
par(mfrow = c(1,1))
dev.off()

# Subsection for plottng log ratio of prey to predator mass
pdf("../results/SizeRatio_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(2,3))
for(type in unique(MyDF$Type.of.feeding.interaction)){
    tmp <- MyDF %>% filter(Type.of.feeding.interaction == type)
    hist(log(tmp$Prey.mass/tmp$Predator.mass), 
         main = type, xlab = "log mass ratio")
}
mtext("Subplots showing the log of Prey mass to Predator mass ratio by feeding interaction", side = 3, line = -1.5, outer = TRUE)
par(mfrow = c(1,1))
dev.off()

# Initializing a new dataframe containing only required variables
# Calculating log ratio
MyNewDF <- MyDF %>% select(Predator.mass, Prey.mass, Type.of.feeding.interaction)
MyNewDF <- MyNewDF %>% mutate(log_ratio = log10(Prey.mass/Predator.mass),
                              Predator.mass = log10(Predator.mass),
                              Prey.mass = log10(Prey.mass))

# Initializing and populating matrix with mean and median values
new_df <- MyNewDF %>% group_by(Type.of.feeding.interaction) %>%
    summarise(LogPredMean = mean(Predator.mass), 
              LogPreyMean = mean(Prey.mass),
              LogRatioMean = mean(log_ratio),
              LogPredMedian = median(Predator.mass),
              LogPreyMedian = median(Prey.mass),
              LogRatioMedian = median(log_ratio))

# Writing the csv output file    
write.csv(new_df, file = '../results/PP_results.csv', row.names = F)

**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 
null device 
          1 
null device 
          1 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file get_TreeHeight.py...

File contents are:

**********************************************************************
"""
Description:
This is the script for the week3 Groupwork on Tree Heights.

Required package for this script:
sys - used for taking argument from the command line
os - used for the elimination of extension from the input name when saving the output file
pandas - used to read the dataset
numpy - used for the mathematical computation

Date:
11 Dec 2022
"""

__author__ = "Xuan Wang xuan.wang22@imperial.ac.uk"
__appname__ = "get_TreeHeight.py"
__package__ = "sys, os, pandas, numpy"

# importing the required package
import sys
import os
import pandas as pd
import numpy as np

# taking the argument from command line
argv = str(sys.argv[1])

# loading dataset
path = ["../data/",argv]
treedata = pd.read_csv("".join(path))
# tree height definition
def TreeHeight(degrees, distance):
    """
    This function defines the function of tree height.
    """
    radians = degrees * np.pi / 180
    height = distance * np.tan(radians)
    return height

# adding the column of tree height to the data
treedata["Tree.Height.m"] = TreeHeight(treedata["Angle.degrees"], treedata["Distance.m"])

# select the first two rows of data
treedata = treedata.head(2)
treedata["Input_Name"] = argv

# saving the output file
path_results = ["../results/",os.path.splitext(argv)[0],"_treeheights.csv"]
treedata.to_csv("".join(path_results))


**********************************************************************

Testing get_TreeHeight.py...

get_TreeHeight.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AditiMadkaikar_/week3/code/get_TreeHeight.py", line 26, in <module>
    argv = str(sys.argv[1])
IndexError: list index out of range

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
# Cleaning the workspace
rm(list = ls())

#install the sqlite package
#install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='../results/Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../data/Resource.csv")  # Read csv files into R

# Import data frames into database
dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
dbListTables(db)                 # The tables in the database
dbListFields(db,"Resource")       # The columns in a table
dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
dbDisconnect(db)            # Close connection
rm(list = c("Resource"))   # Remove data frames
**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************
<SQLiteResult>
  SQL  CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)
  ROWS Fetched: 0 [complete]
       Changed: 0
<SQLiteResult>
  SQL  INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')
  ROWS Fetched: 0 [complete]
       Changed: 1
<SQLiteResult>
  SQL  INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')
  ROWS Fetched: 0 [complete]
       C
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# Function to calculate mean if the number of unique values is greater then 30
doit <- function(x){
    temp_x <- sample(x, replace = T)
    if(length(unique(temp_x)) > 30){
        print(paste("Mean of this sample was:", as.character(mean(temp_x))))
    } else{
        stop("Couldn't calculate mean. Too few variables :(")
    }
}

# Setting seed and generating data
set.seed(1345)
popn <- rnorm(50)
hist(popn)

# Running the doit function with lapply and try
result <- lapply(1:15, function(i) try(doit(popn), F))
result

# Running the doit function the loopy way
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
}

**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"
[1] "Mean of this sample was: 0.0314144452816157"
[1] "Mean of this sample was: -0.233476945796405"
[1] "Mean of this sample was: -0.196681538928001"
[1] "Mean of this sample was: 0.0146969612111605"
[1] "Mean of this sample was: -0.234913159471725"
[1] "Mean of this sample was: -0.0497464588165691"
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in doit(popn) : Couldn't calculate mean. Too few variables :(
Error in doit(popn) : Couldn't calculate mean. Too few variables :(
Error in doit(popn) : Couldn't calculate mean. Too few variables :(
Error in doit(popn) : Couldn't calculate mean. Too few variables :(
Error in doit(popn) : Couldn't calculate mean. Too few variables :(

======================================================================
Inspecting script file PP_regress_loc.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Loading the required packages
library(tidyverse)

# Loading the data as MyDF
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")

# Converting the Prey mass to grams 
MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg'] <- 
    MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg']/1000

# Creating a dataframe of required columns only
new <- MyDF %>% select(Prey.mass, Predator.mass, 
                       Type.of.feeding.interaction, Predator.lifestage,
                       Location)

# Creating an empty data frame
new_df <- data.frame(Type.of.feeding.interaction = character(),
                     Predator.lifestage = character(),
                     Location = character(),
                     Regression.slope = double(), 
                     Regression.intercept = double(), 
                     R.squared = double(), 
                     F.statistic = double(),
                     p.value = double())

# Fitting linear regressions subset-wise and saving the required values to the 
# initialized dataframe

for(inter in unique(new$Type.of.feeding.interaction)){
    for(lifestage in unique(new$Predator.lifestage)){
        for(loc in unique(new$Location)){
            tmp <- new %>%
                filter(Type.of.feeding.interaction == inter,
                       Predator.lifestage == lifestage,
                       Location == loc)
            if(nrow(tmp) > 2){ # Only fitting regression if there are more than 2 observations
                mod <- lm(log10(Predator.mass)~log10(Prey.mass), data = tmp)
                tmp1 <- summary(mod)
                needed <- c(tmp1$coefficients[2,1],
                            tmp1$coefficients[1,1],
                            tmp1$adj.r.squared, 
                            tmp1$fstatistic[1], 
                            tmp1$coefficients[,4][2])
                new_df[nrow(new_df)+1,] <- c(inter, lifestage, loc, needed)
            }
        }
    }
}


# Writing the data frame to a results file
write.csv(new_df, file = '../results/PP_Regress_Results.csv', row.names = F)

**********************************************************************

Testing PP_regress_loc.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Warning messages:
1: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
2: In summary.lm(mod) : essentially perfect fit: summary may be unreliable

======================================================================
Inspecting script file FloridaYears.tex...

File contents are:

**********************************************************************
\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Are temperatures of one year significantly correlated with the next year (successive years), across years in a given location?}
\author{CMEE Group 3 }
\date{December 2022}

\begin{document}

\maketitle

\section{Introduction}
There is significant evidence to assume that the temperature of Florida has been increasing over the years 1901 - 2000, and we wish to determine whether there is also a significant correlation between temperature over the successive years themselves.

\section{Method}
Under the assumption that temperature, the dependant variable is normally distributed, a  two tailed t-test was performed to determine an estimation for the correlation between temperatures across successive years. 

Since observations of the dependent variable (time) are not independent of each-other, a 2 tailed hypothesis test was performed with significance level $\alpha = 0.01$ and with the following null ($H_0$) and alternative ($H_A$) hypotheses, where $r$ is the true correlation, and $r_{observed}$ is the correlation observed within the data.
 \[ H_0: | r | <  r_{observed}\]
    \[H_A: |r| \geq r_{observed} \]

The measurements of temperature were permuted and assigned to years randomly for 10 000 trials. For each trial a paired sample t-test was performed on the newly generated data points and the corresponding correlation was recorded. This calculation was then compared with the correlation calculated for the true data, to investigate how likely a correlation as strong as the one observed is to occur within meaningless data.


\section{Results}
The paired sample t-test performed on the first 99 years and their successive years gave an estimated correlation of 0.3261697.

The correlations calculated for the randomly assigned temperature measurements were greater than 0.3261697 (or less than -0.3261697) for only 0.079\% of the trials. This gives an estimated p-value of 0.00079, which is substantially smaller than the significance level $\alpha$.

Therefore, we can reject $H_0$ and conclude that at a 1\% significance level, the data provides significant evidence that the temperature of Florida is positively correlated across successive years.

\end{document}

**********************************************************************

Testing FloridaYears.tex...

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Loading the required packages
library(tidyverse)

# Loading the data
a <- read.table("../data/Results.txt", header = TRUE)

# Giving the data a look
head(a)

# append a column of zeros
a$ymin <- rep(0, dim(a)[1])

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y1,
    size = (0.5)), 
    colour = "#E69F00", 
    alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y2,
    size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y3,
    size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
    scale_y_continuous("My y axis") + 
    theme_bw() + 
    theme(legend.position = "none") 
p

pdf("../results/MyBars.pdf", 11.7, 8.3)
print(p)
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>
pdf 
  2 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Warning message:
Removed 91 rows containing missing values (geom_text). 
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Basic if-else loop
a <- TRUE
if(a == T){
    print("a is TRUE")
} else{
    print(" a is FALSE")
}

# If statement
z <- runif(1)
if (z <= 0.5) {
    print("Less than half")
}

# For loop
for(i in seq(10)){
    j <- i * i
    print(paste(i, 'i squared is', j))
}

# For loop looping over a vector
for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
    print(paste('The species is', species))
}

# Another for loop
v1 <- c('a', 'bc', 'def')
for(i in v1){
    print(i)
}

# while loop
i <- 0
while(i < 10){
    i <- i+1
    print(i^2)
}

**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than half"
[1] "1 i squared is 1"
[1] "2 i squared is 4"
[1] "3 i squared is 9"
[1] "4 i squared is 16"
[1] "5 i squared is 25"
[1] "6 i squared is 36"
[1] "7 i squared is 49"
[1] "8 i squared is 64"
[1] "9 i squared is 81"
[1] "10 i squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.20123s

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:

**********************************************************************
## TAutoCorr.R ##
load("../data/KeyWestAnnualMeanTemperature.RData")


df <- data.frame(ats$Temp[1:99], ats$Temp[2:100])
names(df) <- c("Temp", "Successive Temp")
 
# paired t-test
cor.test(df$Temp, df$`Successive Temp`)

## randomly permute time series ##


n <- 100000                 #number of trials
random_successes <- 0       #count of randomly generated correlations which are stronger than test statistic
success_list <- list()      #list random successes

for (i in 1:n){
  new_tempseries <- sample(ats$Temp, 100, replace = F)        #permutes temperature measurements
  new_DF <- data.frame(new_tempseries[1:99], new_tempseries[2:100])                 #forms new data frame of first 99 years and their successive years
  correlation <- as.numeric(cor.test(new_DF[[1]], new_DF[[2]])['estimate'])         #determines correlation
  if ( abs(correlation) >= cor.test(df$Temp, df$`Successive Temp`)['estimate'])  {  #counts and stores correlation if stronger than correlation observed for true data
    random_successes = random_successes + 1
    success_list <- append(success_list, correlation)
  }
}

#find percentage
rate = random_successes / n
print(rate)

#differenciate between negative and positive correlations
length(success_list[success_list < 0])
length(success_list[success_list > 0])
**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 


**********************************************************************

	Pearson's product-moment correlation

data:  df$Temp and df$`Successive Temp`
t = 3.3982, df = 97, p-value = 0.0009852
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 0.1376191 0.4919077
sample estimates:
      cor 
0.3261697 


**********************************************************************

Code ran without errors

Time consumed = 10.00626s

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# Function to return the simulation of the Ricker model
Ricker <- function(N0=1, r=1, k=10, generations=50){
    # Runs a simulation of the Ricker model
    # Returns a vector of length generations
    N <- rep(NA, generations)
    N[1] <- N0
    for (t in 2:generations){
        N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/k)))
    }
    return(N)
}

# Plotting the results of the simulation
plot(Ricker(generations = 10), type ='l')
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.23351s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

# Cleaning data
rm(list = ls())

# Weird function
MyFunction <- function(Arg1, Arg2){
    # Statements involving Arg1 and Arg2
    print(paste("Argument", Arg1, "is a", class(Arg1)))
    print(paste("Argument", Arg1, "is a", class(Arg1)))
    
    return(c(Arg1, Arg2))
}

MyFunction(1,2)
MyFunction('Riki', 'Tiki')
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 1 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Riki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.20480s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Conditional function 1: Checks if numbers are even or odd
is.even <- function(n = 2){
    if (n %% 2 == 0){
        return(paste(n , 'is even!'))
    } else{
        return(paste(n, 'is odd! :('))
    }
}

print(is.even(7))

# Conditional function 2: Checks if a number is a power of 2
is.power2 <- function(n = 2){
    if(log2(n) %% 1 == 0){
        return(paste(n, 'is power of 2!'))
    } else{
        return(paste(n, 'is not a power of 2 :('))
    }
}

print(is.power2(7))

# Conditional function 3: Checks if it is a prime number
is.prime <- function(n){
    if(n==0){
        return(paste(n, 'is zero'))
    } else if (n==1){
        return(paste(n, 'is just a unit :('))
    } 
    ints <- 2:(n-1)
    
    if (all(n%%ints !=0)){
        return(paste(n, 'is a prime!'))
    } else {
        return(paste(n, 'is a composite :('))
    }
}

print(is.prime(4))

**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "7 is odd! :("
[1] "7 is not a power of 2 :("
[1] "4 is a composite :("

**********************************************************************

Code ran without errors

Time consumed = 0.18445s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
# cleaning the environment 
rm(list = ls())

# Function for simulation of exponential growth
Exponential <- function(N0 = 1, r = 1, generations = 10){
    # Runs a simulation of exponential growth
    # Returns a vector of length generations
    
    N <- rep(NA, generations)
    N[1] <- N0
    for (t in 2:generations){
        N[t] <- N[t-1] * exp(r)
        browser()
    }
    return(N)
}

# Plotting the results
plot(Exponential(), type = 'l', main = "Exponential Growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.24180s

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
# Cleaning the workspace
rm(list = ls())

# Loading required packages
require(tidyverse)
require(maps)

# Loading the dataset
load("../data/GPDDFiltered.RData")

# Plottng blank world map and axes
map()
map.axes()

# Superimposing the points from gpdd data
points(gpdd$long, gpdd$lat, col ='red', pch =16)

# The observations are concentrated in the Northern hemisphere.
# In particular they are concentrated in North America and Europe. 
# There are very few observations from the southern and eastern hemispheres.
# This will cause biases during analyses. 
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: maps

Attaching package: ‘maps’

The following object is masked from ‘package:purrr’:

    map


======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Loading the required packages
library(tidyverse)

# Loading the data as MyDF
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")

# Converting the Prey mass to grams 
MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg'] <- 
    MyDF$Prey.mass[MyDF$Prey.mass.unit == 'mg']/1000

# Building the plot
g <- ggplot(MyDF, aes(x = log10(Prey.mass), y = log10(Predator.mass), 
                      colour = Predator.lifestage)) +
    geom_point(shape = I(3)) + 
    geom_smooth(method = "lm", aes(colour=Predator.lifestage), fullrange=T)
    theme_classic()

# Wrapping it for Type of feeding interaction
g <- g + facet_wrap(.~Type.of.feeding.interaction, 
                    ncol=1, strip.position = "right") 

# Adding the legend
g <- g + theme_bw() + theme(legend.position = "bottom") + 
    guides(color = guide_legend(nrow = 1))

# Setting the x-axis
g <- g + scale_x_continuous(labels = c('1e-07', '1e-03', '1e+01'), 
                            breaks = c(-7, -3, 1)) 

# Setting the y-axis
g <- g + scale_y_continuous(labels = c('1e-06', '1e-02', '1e+02', '1e+06'), 
                            breaks = c(-6, -2, 2, 6)) 

# Setting the axes names
g <- g + xlab("Prey mass in grams") + ylab("Predator mass in grams")
g

# Printing the output to a PDF file
pdf("../results/PP_Regress_plot.pdf", 11.7, 8.3)
print(g)
dev.off()

# Creating a dataframe of required columns only
new <- MyDF %>% select(Prey.mass, Predator.mass, 
                       Type.of.feeding.interaction, Predator.lifestage)

# Creating an empty data frame
new_df <- data.frame(Type.of.feeding.interaction = character(),
                     Predator.lifestage = character(), 
                     Regression.slope = double(), 
                     Regression.intercept = double(), 
                     R.squared = double(), 
                     F.statistic = double(),
                     p.value = double())

# Fitting linear regressions subset-wise and saving the required values to the 
# initialized dataframe

for(inter in unique(new$Type.of.feeding.interaction)){
    for(lifestage in unique(new$Predator.lifestage)){
        tmp <- new %>%
            filter(Type.of.feeding.interaction == inter,
                   Predator.lifestage == lifestage)
        if(nrow(tmp) > 2){ # Only fitting regression if there are more than 2 observations
            mod <- lm(log10(Predator.mass)~log10(Prey.mass), data = tmp)
            tmp1 <- summary(mod)
            needed <- c(tmp1$coefficients[2,1],
                        tmp1$coefficients[1,1],
                        tmp1$adj.r.squared, 
                        tmp1$fstatistic[1], 
                        tmp1$coefficients[,4][2])
            new_df[nrow(new_df)+1,] <- c(inter, lifestage, needed)
        }
    }
}

# Writing the data frame to a results file
write.csv(new_df, file = '../results/PP_Regress_Results.csv', row.names = F)

**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************
List of 93
 $ line                      :List of 6
  ..$ colour       : chr "black"
  ..$ size         : num 0.5
  ..$ linetype     : num 1
  ..$ lineend      : chr "butt"
  ..$ arrow        : logi FALSE
  ..$ inherit.blank: logi TRUE
  ..- attr(*, "class")= chr [1:2] "element_line" "element"
 $ rect                      :List of 5
  ..$ fill         : chr "white"
  ..$ colour       : chr "black"
  ..$ size         : num 0.5
  ..$ linetype     : num 1
  ..$ inherit.blank: logi TRUE
  ..- attr(*, 
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:

**********************************************************************
#!/usr/bin/env Rscript

# loading the packages
library(tools)

# loading data from the command line
argv <- commandArgs(trailingOnly = TRUE)
treedata <- read.csv(paste("../data/", argv[1], sep = ""))

TreeHeight <- function(degrees, distance) {

    radians <- degrees * pi / 180
    height <- distance * tan(radians)

    return(height)
}

for (Species in treedata) {
    treehgt <- TreeHeight(treedata$Angle.degrees, treedata$Distance.m)
    return(treehgt)
} 

## add the column of height to the data
treedata$Tree.Height.m <- treehgt

## select the first two rows of data
height_selected <- treedata[1:2,]
height_selected$Input_Name <- argv[1]

## saving the output file
output <- basename(file_path_sans_ext(argv[1]))
write.csv(height_selected, file = paste("../results/", output, "_treeheights.csv", sep = ""))
**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/NA': No such file or directory
Execution halted

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations
# cleaning the environment 
rm(list = ls())

# Setting the seed 
set.seed(123456)

# Non-vectotized stochastic Ricker equation with gaussian fluctuations
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, 
                      K = 1, sigma = 0.2,numyears = 1000){

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K)
                                       + rnorm(1, 0, sigma))
      
      # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)
}

# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: 

# Re-setting the seed
set.seed(123456)

# Vectorized function for stochastic simulation of the Ricker model with 
# gaussian fluctuations
stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, 
                          K = 1, sigma = 0.2,numyears = 1000){
    # Generating empty matrix of fixed dimensions 
    N <- matrix(NA, numyears, length(p0))
    # Assigning p0 to the first row
    N[1,] <- p0
    
    # Vectorizing over p0 and looping over the years
    for(i in 2:numyears){
        N[i,] <- N[i-1,] * exp(r * (1 - N[i-1,] / K) + 
                                   rnorm(length(p0), 0, sigma))
    }
    return(N)
}

# Results for vectorized model
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

# Results for non-vectorized model
print("Not vectorized Stochastic Ricker takes:")
print(system.time(res1<-stochrick()))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.114   0.011   0.125 
[1] "Not vectorized Stochastic Ricker takes:"
   user  system elapsed 
  1.910   0.000   1.912 

**********************************************************************

Code ran without errors

Time consumed = 2.26975s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
library(tidyverse)

PoundHillData <- read_csv("../week3/data/PoundHillData.csv", col_names = FALSE, na = "0")
PoundHillData[PoundHillData == ""] <- '0'
PoundHillData <- t(PoundHillData)
PoundFinal <- as_tibble(PoundHillData[-1,])
colnames(PoundFinal) <- PoundHillData[1,]
PoundLong <- pivot_longer(PoundFinal, 
                          -c("Cultivation", "Block", "Plot", "Quadrat"),
                          names_to = "Species", values_to = "Count")
t <- PoundLong %>% mutate_at(vars(Cultivation, Block, 
                                  Plot, Quadrat, Species), list(factor))
MyWrangledData <- t %>% mutate(across(Count, as.integer))

filter(MyWrangledData, Count>100) #like subset(), but nicer!
slice(MyWrangledData, 10:15) # Look at a particular range of data rows

MyWrangledData %>%
    group_by(Species) %>%
    summarise(avg = mean(Count))

**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Error: '../week3/data/PoundHillData.csv' does not exist in current working directory ('/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/AditiMadkaikar_/week3/code').
Execution halted

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# No preallocated way of concatenating to a vector
NoPreallocFun <- function(x) {
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i) # concatenate
        #print(a)
        #print(object.size(a))
    }
}

system.time(NoPreallocFun(1000))

# Preallocated way of filling a vector
PreallocFun <- function(x) {
    a <- rep(NA, x) # pre-allocated vector
    for (i in 1:x) {
        a[i] <- i # assign
        #print(a)
        #print(object.size(a))
    }
}

system.time(PreallocFun(1000))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
   user  system elapsed 
  0.016   0.000   0.016 
   user  system elapsed 
  0.003   0.000   0.003 

**********************************************************************

Code ran without errors

Time consumed = 0.23484s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# breaking a while loop
i <- 0
while(i < Inf){
    if(i == 10){
        break
    } else{
        cat('i equals', i, '\n')
        i <- i + 1
    }
}

**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals 0 
i equals 1 
i equals 2 
i equals 3 
i equals 4 
i equals 5 
i equals 6 
i equals 7 
i equals 8 
i equals 9 

**********************************************************************

Code ran without errors

Time consumed = 0.19785s

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:

**********************************************************************
#!/bin/sh
# Author: Xuan Wang xuan.wang22@imperial.ac.uk
# Date: 11 Dec 2022
# Description: This script runs both the get_TreeHeight files for R and python.

# Testing of R file
echo "R script started."
Rscript get_TreeHeight.R trees.csv
echo "R script done!"

# Testing of python file
echo "Python script started."
ipython3 get_TreeHeight.py trees.csv
echo "Python script done!"
**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 


**********************************************************************
R script started.
R script done!
Python script started.
[22;0t]0;IPython: week3/codePython script done!

**********************************************************************

Code ran without errors

Time consumed = 0.94350s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())
# Loading the required packages
require(tidyverse)
require(reshape2)

# loading the data and saving it as a matrix without headers
MyData <- as.matrix(read.csv('../data/PoundHillData.csv', header = F))

# Substituing 0s for missing data
MyData[MyData == ""] <- 0
# Transposing data to make it suitable for working on
MyData <- t(MyData)

# Converting it to a dataframe and adding column names
TempData <- as.data.frame(MyData[-1,], stringsAsFactors = F)
colnames(TempData) <- MyData[1,]

# Using melt to convert it to long form
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

# Converting variables to required format
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)

# Using dplyr to convert the data to tibble
MyWrangledData <- dplyr::as_tibble(MyWrangledData)
filter(MyWrangledData, Count>100) #like subset(), but nicer!
slice(MyWrangledData, 10:15) # Look at a particular range of data rows

# A random pipe operation in dplyr
MyWrangledData %>%
    group_by(Species) %>%
    summarise(avg = mean(Count))

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
'data.frame':	2419 obs. of  6 variables:
 $ Cultivation: Factor w/ 3 levels "march","may",..: 3 3 3 3 3 2 2 2 2 2 ...
 $ Block      : Factor w/ 4 levels "a","b","c","d": 1 1 1 1 1 1 1 1 1 1 ...
 $ Plot       : Factor w/ 12 levels "1","10","11",..: 1 1 1 1 1 5 5 5 5 5 ...
 $ Quadrat    : Factor w/ 6 levels "Q1","Q2","Q3",..: 1 2 3 4 5 1 2 3 4 5 ...
 $ Species    : Factor w/ 41 levels "Achillea millefolium",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ Count      : int  4 8 3 20 6 4 0 0 0 0 ...
# A tibble: 21 x 6
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.1     ✔ dplyr   1.0.6
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: reshape2

Attaching package: ‘reshape2’

The following object is masked from ‘package:tidyr’:

    smiths


======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree from its 
# base and angle to its top using trigonometric formula
#
# height = distance * tan(radians)
#
# ARGUMENTS
#
# degrees: The angle of elevation of trees
# distance: The distance from base of tree (e.g meters)
#
# OUTPUT
# The heights of tree (same units as distance)

# Cleaning the environment
rm(list = ls())

# Loading the data
trees <- read.csv('../data/trees.csv', header = T)

# Tree height calculating function
TreeHeight <- function(degrees, distance){
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste('The height is:', height))
    
    return(height)
}

# Adding a new column to the data frame 
trees$Tree.Height.m <- TreeHeight(trees$Angle.degrees, trees$Distance.m)

# Writing a csv with the tree heights
write.csv(trees, '../results/TreeHts.csv')

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
  [1] "The height is: 27.8021161438536" "The height is: 45.2460250644405"
  [3] "The height is: 14.6654828109493" "The height is: 14.9341751666304"
  [5] "The height is: 35.9703591412599" "The height is: 32.4102133664874"
  [7] "The height is: 17.4582436344144" "The height is: 30.1373803987097"
  [9] "The height is: 20.3124778877177" "The height is: 24.4316633466933"
 [11] "The height is: 27.5021323376702" "The height is: 25.1559006982628"
 [13] "The height is: 29.3924796426504" "The height is: 2
**********************************************************************

Code ran without errors

Time consumed = 0.18134s

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# A simple script to illustrate R input and output
# Run line by line and check inputs outputs to understand what is happening

MyData <- read.csv('../data/trees.csv', header = T)

write.csv(MyData, '../results/MyData.csv')
write.table(MyData[1,], file = '../results/MyData.csv', append = T)
write.csv(MyData, '../results/MyData.csv', row.names = T)
write.table(MyData, '../results/MyData.csv', col.names = F)

**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = T) :
  appending column names to file

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
# Cleaning the environment
rm(list = ls())

# Generate a matrix of random uniform numbers
M <- matrix(runif(1000000), 1000, 1000)

# Function for summing all elements using the loopy way
SumAllElements <- function(M){
    Dimensions <- dim(M)
    Tot <- 0
    for (i in 1:Dimensions[1]){
        for (j in 1:Dimensions[2]){
            Tot <- Tot + M[i, j]
        }
    }
    return(Tot)
}

# Printing loopy way results
print("Using loops the time taken is: ")
print(system.time(SumAllElements(M)))

# Printing vectorized way results
print("Using the built in vectorized function, the time taken is: ")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops the time taken is: "
   user  system elapsed 
  0.065   0.000   0.067 
[1] "Using the built in vectorized function, the time taken is: "
   user  system elapsed 
  0.001   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.32073s

======================================================================
Inspecting script file Florida_results.tex...

File contents are:

**********************************************************************
\documentclass[12pt]{article}

\title{Is Florida getting warmer}

\usepackage{graphicx}
%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
    \maketitle

    \section{Introduction}
        This report checks whether Florida is getting warmer over the years. It checks whether the correlation between the variables is a result of chance or if it is significant by itself

    \section{Methods}
        The correlation between the temperature and year is calculated using the cor function in R. 
        The significance of this observed correlation is verified using the a permutation analysis. 

    \section{Results}    
    \begin{figure}
        \centering
        \begin{subfigure}{.5\textwidth}
          \centering
          \includegraphics[width=.75\linewidth]{../../week3/data/latex1.png}
          \caption{A subfigure}
          \label{fig:sub1}
        \end{subfigure}%
        \begin{subfigure}{.5\textwidth}
          \centering
          \includegraphics[width=.75\linewidth]{../../week3/data/latex2.png}
          \caption{A subfigure}
          \label{fig:sub2}
        \end{subfigure}
        \label{fig_req}
    \end{figure}

        As seen from \ref{fig:sub1} there is a increase in temperature over time. To verify whether this increase is significant a permutation analysis of the data was done.
        \ref{fig:sub2} shows that the observed correlation is greater than the correlation acquired by random reshuffling. This proves that Florida is getting warmer.

    \end{document}
    
**********************************************************************

Testing Florida_results.tex...

======================================================================
======================================================================
Finished running scripts

Ran into 15 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!